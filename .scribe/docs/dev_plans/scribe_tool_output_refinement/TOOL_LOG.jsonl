# Progress Log

[ℹ️] [2026-01-04 01:43:13 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: set_project | format_requested=readable; response_data={"docs_created": {"architecture": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/ARCHITECTURE_GUIDE.md", "checklist": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/CHECKLIST.md", "phase_plan": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/PHASE_PLAN.md", "progress_log": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/PROGRESS_LOG.md"}, "is_new": true, "ok": true, "project": {"author": "Scribe", "defaults": {"agent": "Scribe"}, "description": null, "docs": {"architecture": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/ARCHITECTURE_GUIDE.md", "checklist": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/CHECKLIST.md", "phase_plan": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/PHASE_PLAN.md", "progress_log": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/PROGRESS_LOG.md"}, "docs_dir": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement", "name": "scribe_tool_output_refinement", "progress_log": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/PROGRESS_LOG.md", "root": "/home/austin/projects/MCP_SPINE/scribe_mcp", "tags": []}, "readable_content": "\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 \u2728 NEW PROJECT CREATED: scribe_tool_output_refinement      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\ud83d\udcc2 Location:\n  Root: /home/austin/projects/MCP_SPINE/scribe_mcp\n  Dev Plan: .scribe/docs/dev_plans/scribe_tool_output_refinement/\n\n\ud83d\udcc4 Documents Created:\n  \u2713 ARCHITECTURE_GUIDE.md (template, 1887 lines)\n  \u2713 PHASE_PLAN.md (template, 908 lines)\n  \u2713 CHECKLIST.md (template, 598 lines)\n  \u2713 PROGRESS_LOG.md (empty, ready for entries)\n\n\ud83c\udfaf Status: planning (new project)\n\ud83d\udca1 Next: Start with research or architecture phase"}; timestamp=2026-01-04T01:43:13.620383Z; tool=set_project; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:43:23 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "scan_only", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/utils/reminder_engine.py", "byte_size": 24475, "encoding": "utf-8", "estimated_chunk_count": 3, "line_count": 592, "newline_type": "LF", "repo_relative_path": "utils/reminder_engine.py", "sha256": "3b52087f6e7bf1fefd74c87814f20198863a1b9632bae80f5855b22c0bf1ec97"}}; timestamp=2026-01-04T01:43:23.898199Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:43:26 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"chunks": [{"byte_end": 7426, "byte_start": 0, "chunk_index": 0, "content": "\"\"\"Advanced reminder engine with localization and intelligent selection.\n\nThis module provides a sophisticated reminder system that:\n- Loads reminders from configurable JSON files\n- Supports multiple languages with fallbacks\n- Implements intelligent reminder selection and deduplication\n- Provides progressive teaching with cooldown periods\n- Uses variable substitution for dynamic content\n\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nimport json\nimport os\nimport time\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Set, Tuple\nfrom datetime import datetime, timezone, timedelta\n\nfrom scribe_mcp.config.settings import settings\n\n\n@dataclass\nclass ReminderInstance:\n    \"\"\"A single reminder instance with metadata.\"\"\"\n    key: str\n    level: str\n    emoji: str\n    message: str\n    context: Optional[str] = None\n    category: str = \"general\"\n    score: int = 3\n    variables: Dict[str, Any] = field(default_factory=dict)\n    tools_suppressed: List[str] = field(default_factory=list)\n    cooldown_minutes: int = 0\n    last_shown: Optional[datetime] = None\n\n\n@dataclass\nclass ReminderContext:\n    \"\"\"Context for reminder generation.\"\"\"\n    tool_name: str\n    project_name: Optional[str]\n    project_root: Optional[str]\n    agent_id: Optional[str]\n    session_id: Optional[str] = None\n    total_entries: int = 0\n    minutes_since_log: Optional[float] = None\n    last_log_time: Optional[datetime] = None\n    docs_status: Dict[str, str] = field(default_factory=dict)\n    docs_changed: List[str] = field(default_factory=list)\n    current_phase: Optional[str] = None\n    session_age_minutes: Optional[float] = None\n    variables: Dict[str, Any] = field(default_factory=dict)\n    operation_status: Optional[str] = None  # \"success\", \"failure\", or None for neutral\n\n\n@dataclass\nclass ReminderHistory:\n    \"\"\"Tracks recently shown reminders for deduplication.\"\"\"\n    reminder_hashes: Dict[str, datetime] = field(default_factory=dict)\n    teaching_sessions: Dict[str, int] = field(default_factory=dict)\n    last_cleanup: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n\nclass ReminderEngine:\n    \"\"\"Advanced reminder engine with localization and intelligent selection.\"\"\"\n\n    def __init__(self, config_path: Optional[str] = None):\n        self.config_path = config_path or \"config/reminder_config.json\"\n        self.reminders_path: Optional[str] = None\n        self.rules_path: Optional[str] = None\n\n        self.config: Dict[str, Any] = {}\n        self.reminders: Dict[str, Any] = {}\n        self.rules: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.formatting: Dict[str, Any] = {}\n\n        self.language = \"en-US\"\n        self.fallback_language = \"en-US\"\n\n        self.history = ReminderHistory()\n        self._cooldown_cache_path: Optional[Path] = None\n        self._cooldown_cache_dirty = False\n\n        self._load_configuration()\n\n    def _load_configuration(self) -> None:\n        \"\"\"Load all configuration files.\"\"\"\n        try:\n            config_file = Path(self.config_path)\n            if config_file.exists():\n                self.config = json.loads(config_file.read_text(encoding=\"utf-8\"))\n                self.language = self.config.get(\"language\", \"en-US\")\n                self.fallback_language = self.config.get(\"fallback_language\", \"en-US\")\n\n                base_path = config_file.parent\n                self.reminders_path = base_path / self.config.get(\"reminder_paths\", {}).get(\"templates\", \"reminders\")\n                self.rules_path = base_path / self.config.get(\"reminder_paths\", {}).get(\"rules\", \"reminder_rules.json\")\n\n            self._load_reminders()\n            self._load_rules()\n            self._configure_cooldown_cache()\n            self._load_cooldown_cache()\n\n        except Exception as e:\n            print(f\"Warning: Failed to load reminder configuration: {e}\")\n            self._load_fallback_reminders()\n\n    def _load_reminders(self) -> None:\n        \"\"\"Load reminder templates for current language.\"\"\"\n        if not self.reminders_path:\n            return\n\n        # Try to load preferred language\n        lang_file = self.reminders_path / f\"{self.language}.json\"\n        if lang_file.exists():\n            self.reminders = json.loads(lang_file.read_text(encoding=\"utf-8\"))\n            self.variables = self.reminders.get(\"variables\", {})\n            self.formatting = self.reminders.get(\"formatting\", {})\n            return\n\n        # Fallback to default language\n        fallback_file = self.reminders_path / f\"{self.fallback_language}.json\"\n        if fallback_file.exists():\n            self.reminders = json.loads(fallback_file.read_text(encoding=\"utf-8\"))\n            self.variables = self.reminders.get(\"variables\", {})\n            self.formatting = self.reminders.get(\"formatting\", {})\n\n    def _load_rules(self) -> None:\n        \"\"\"Load reminder selection rules.\"\"\"\n        if not self.rules_path or not self.rules_path.exists():\n            return\n\n        self.rules = json.loads(self.rules_path.read_text(encoding=\"utf-8\"))\n\n    def _load_fallback_reminders(self) -> None:\n        \"\"\"Load minimal fallback reminders.\"\"\"\n        self.reminders = {\n            \"reminders\": {\n                \"logging\": {\n                    \"no_logs_yet\": {\n                        \"level\": \"info\",\n                        \"emoji\": \"\ud83d\udcdd\",\n                        \"template\": \"No progress logs yet. Use append_entry to start the audit trail.\",\n                        \"category\": \"logging\"\n                    }\n                },\n                \"context\": {\n                    \"project_context\": {\n                        \"level\": \"info\",\n                        \"emoji\": \"\ud83c\udfaf\",\n                        \"template\": \"Project: {project_name}\",\n                        \"category\": \"context\"\n                    }\n                }\n            }\n        }\n        self.config = {\n            \"behavior\": {\"max_reminders_per_call\": 2},\n            \"selection\": {\"priority_order\": [\"urgent\", \"warning\", \"info\"]}\n        }\n\n    def _cleanup_history(self) -> None:\n        \"\"\"Clean up old reminder history.\"\"\"\n        now = datetime.now(timezone.utc)\n        cleanup_after_hours = self.config.get(\"tracking\", {}).get(\"cleanup_after_hours\", 24)\n        cutoff = now - timedelta(hours=cleanup_after_hours)\n\n        # Remove old reminder hashes\n        self.history.reminder_hashes = {\n            h: t for h, t in self.history.reminder_hashes.items()\n            if t > cutoff\n        }\n\n        # Remove old teaching sessions\n        self.history.teaching_sessions = {\n            k: v for k, v in self.history.teaching_sessions.items()\n            if v > 0  # Sessions reset when count reaches 0\n        }\n\n        self.history.last_cleanup = now\n\n        # Keep the persisted cooldown cache bounded as well.\n        self._cleanup_cooldown_cache()\n        self._save_cooldown_cache()\n\n    def _configure_cooldown_cache(self) -> None:\n        override = os.environ.get(\"SCRIBE_REMINDER_CACHE_PATH\")\n        if override:\n            self._cooldown_cache_path = Path(override).expanduser()\n            return\n\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        path_raw = behavior.get(\"cooldown_cache_path\", \"data/reminder_cooldowns.json\")\n        path_obj = Path(path_raw).expanduser()\n        if not path_obj.is_absolute():\n", "line_end": 200, "line_start": 1}, {"byte_end": 16238, "byte_start": 7426, "chunk_index": 1, "content": "            path_obj = (settings.project_root / path_obj).resolve()\n        self._cooldown_cache_path = path_obj\n\n    def _load_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        enabled = bool(behavior.get(\"persist_cooldowns\", True))\n        if not enabled or not self._cooldown_cache_path:\n            return\n\n        try:\n            path = self._cooldown_cache_path\n            if not path.exists():\n                return\n            raw = json.loads(path.read_text(encoding=\"utf-8\"))\n            entries = raw.get(\"entries\", raw) if isinstance(raw, dict) else {}\n            if not isinstance(entries, dict):\n                return\n\n            loaded: Dict[str, datetime] = {}\n            for key, ts in entries.items():\n                if not isinstance(key, str) or not isinstance(ts, str):\n                    continue\n                try:\n                    dt = datetime.fromisoformat(ts)\n                    if dt.tzinfo is None:\n                        dt = dt.replace(tzinfo=timezone.utc)\n                    else:\n                        dt = dt.astimezone(timezone.utc)\n                    loaded[key] = dt\n                except ValueError:\n                    continue\n\n            if loaded:\n                self.history.reminder_hashes.update(loaded)\n        except Exception:\n            return\n\n    def _save_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        enabled = bool(behavior.get(\"persist_cooldowns\", True))\n        if not enabled or not self._cooldown_cache_path or not self._cooldown_cache_dirty:\n            return\n\n        try:\n            path = self._cooldown_cache_path\n            path.parent.mkdir(parents=True, exist_ok=True)\n            payload = {\n                \"version\": 1,\n                \"written_at\": datetime.now(timezone.utc).isoformat(),\n                \"entries\": {k: v.isoformat() for k, v in self.history.reminder_hashes.items()},\n            }\n            tmp = path.with_suffix(path.suffix + \".tmp\")\n            tmp.write_text(json.dumps(payload, sort_keys=True), encoding=\"utf-8\")\n            tmp.replace(path)\n            self._cooldown_cache_dirty = False\n        except Exception:\n            return\n\n    def _cleanup_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        retention_minutes = int(behavior.get(\"cooldown_cache_retention_minutes\", 24 * 60))\n        cutoff = datetime.now(timezone.utc) - timedelta(minutes=max(1, retention_minutes))\n        before = len(self.history.reminder_hashes)\n        self.history.reminder_hashes = {\n            k: v for k, v in self.history.reminder_hashes.items()\n            if v >= cutoff\n        }\n        if len(self.history.reminder_hashes) != before:\n            self._cooldown_cache_dirty = True\n\n    def reset_cooldowns(self, *, project_root: str, agent_id: Optional[str] = None) -> int:\n        prefix = f\"{project_root} \"\n        if agent_id:\n            prefix = f\"{project_root} {agent_id} \"\n\n        keys = [k for k in self.history.reminder_hashes.keys() if k.startswith(prefix)]\n        for key in keys:\n            self.history.reminder_hashes.pop(key, None)\n        if keys:\n            self._cooldown_cache_dirty = True\n            self._save_cooldown_cache()\n        return len(keys)\n\n    def _get_reminder_hash(self, reminder_key: str, variables: Dict[str, Any]) -> str:\n        \"\"\"Generate hash for reminder deduplication.\n\n        Uses session_id when use_session_aware_hashes flag is enabled.\n        Falls back to legacy format for backward compatibility.\n        \"\"\"\n        use_session_hash = getattr(settings, 'use_session_aware_hashes', False)\n        session_id = str(variables.get(\"session_id\") or \"\")\n\n        if use_session_hash and session_id:\n            # Session-aware hash (new behavior)\n            parts = [\n                session_id,\n                str(variables.get(\"project_root\") or \"\"),\n                str(variables.get(\"agent_id\") or \"\"),\n                str(variables.get(\"tool_name\") or \"\"),\n                reminder_key\n            ]\n        else:\n            # Legacy hash (backward compatible)\n            parts = [\n                str(variables.get(\"project_root\") or \"\"),\n                str(variables.get(\"agent_id\") or \"\"),\n                str(variables.get(\"tool_name\") or \"\"),\n                reminder_key\n            ]\n\n        return hashlib.md5(\" \".join(parts).encode()).hexdigest()\n\n    def _should_show_reminder(self, reminder: ReminderInstance, context: ReminderContext) -> bool:\n        \"\"\"Check if reminder should be shown based on rules.\n\n        Failure-priority logic: When operation_status == \"failure\", cooldowns are bypassed\n        to ensure critical reminders are shown on tool failures.\n        \"\"\"\n\n        # Tool suppression\n        if context.tool_name in reminder.tools_suppressed:\n            return False\n\n        # Failure-priority logic: bypass cooldowns on failures\n        is_failure = context.operation_status == \"failure\"\n\n        # Cooldown check (bypassed for failures)\n        if not is_failure:\n            cooldown_minutes = reminder.cooldown_minutes\n            if cooldown_minutes <= 0 and reminder.category == \"teaching\":\n                cooldown_minutes = int(self.config.get(\"behavior\", {}).get(\"default_teaching_cooldown_minutes\", 10))\n\n            if cooldown_minutes > 0:\n                reminder_hash = self._get_reminder_hash(reminder.key, reminder.variables)\n                last_shown = self.history.reminder_hashes.get(reminder_hash)\n                if last_shown:\n                    cooldown_cutoff = datetime.now(timezone.utc) - timedelta(minutes=cooldown_minutes)\n                    if last_shown > cooldown_cutoff:\n                        return False\n\n        # Teaching session limits (bypassed for failures)\n        if not is_failure and reminder.category == \"teaching\":\n            session_key = f\"{context.tool_name}:{reminder.key}\"\n            sessions_used = self.history.teaching_sessions.get(session_key, 0)\n            max_sessions = self.config.get(\"behavior\", {}).get(\"max_teaching_reminders_per_session\", 3)\n            if sessions_used >= max_sessions:\n                return False\n\n        return True\n\n    def _format_reminder(self, reminder: ReminderInstance, use_short: bool = True) -> ReminderInstance:\n        \"\"\"Apply variable substitution and formatting to reminder.\"\"\"\n        # Choose template\n        template_key = \"short_template\" if use_short and \"short_template\" in reminder.variables else \"template\"\n        template = reminder.variables.get(template_key, reminder.message)\n\n        # Variable substitution\n        try:\n            formatted_message = template.format(**reminder.variables)\n            if reminder.context:\n                formatted_context = reminder.context.format(**reminder.variables)\n                reminder.context = formatted_context\n        except KeyError as e:\n            # Fallback to original template if variable missing\n            formatted_message = reminder.message\n\n        reminder.message = formatted_message\n        return reminder\n\n    def _evaluate_condition(self, condition: str, context: ReminderContext) -> bool:\n        \"\"\"Evaluate a condition string against context.\"\"\"\n        # Simple condition evaluation (can be extended)\n        if condition == \"no_log_entries\":\n            return context.total_entries == 0\n        elif condition.startswith(\"minutes_since_log > \"):\n            threshold = int(condition.split()[-1])\n            return (context.minutes_since_log or 0) > threshold\n        elif condition == \"docs_missing\":\n            return any(status == \"missing\" for status in context.docs_status.values())\n        elif condition.startswith(\"tool=\"):\n            return context.tool_name == condition.split(\"=\")[1]\n        elif condition.startswith(\"action=\"):\n            return context.variables.get(\"action\") == condition.split(\"=\")[1]\n        elif condition.startswith(\"scaffold=\"):\n            expected = condition.split(\"=\")[1].strip().lower()\n            actual = context.variables.get(\"scaffold\")\n            if isinstance(actual, bool):\n                actual_value = \"true\" if actual else \"false\"\n            else:\n                actual_value = str(actual).strip().lower()\n            return actual_value == expected\n        elif condition == \"always\":\n            return True\n\n        return False\n\n    def _build_variables(self, context: ReminderContext) -> Dict[str, Any]:\n        \"\"\"Build variable dictionary for template substitution.\"\"\"\n        now_utc = datetime.now(timezone.utc)\n        date_format = self.formatting.get(\"date_format\", \"%Y-%m-%d %H:%M UTC\")\n", "line_end": 400, "line_start": 201}, {"byte_end": 24475, "byte_start": 16238, "chunk_index": 2, "content": "\n        variables = {\n            \"project_name\": context.project_name or \"No project\",\n            \"project_root\": context.project_root or \"\",\n            \"agent_id\": context.agent_id or \"\",\n            \"session_id\": context.session_id or \"\",\n            \"tool_name\": context.tool_name,\n            \"total_entries\": context.total_entries,\n            \"minutes\": int(context.minutes_since_log or 0),\n            \"hours\": int((context.minutes_since_log or 0) / 60),\n            \"days\": int((context.minutes_since_log or 0) / 1440),\n            \"now_utc\": now_utc.strftime(date_format),\n            \"now_iso_utc\": now_utc.isoformat(),\n            \"date_utc\": now_utc.strftime(\"%Y-%m-%d\"),\n            \"time_utc\": now_utc.strftime(\"%H:%M:%S UTC\"),\n        }\n\n        # Time formatting\n        if context.last_log_time:\n            variables[\"last_log\"] = context.last_log_time.strftime(\n                date_format\n            )\n        else:\n            variables[\"last_log\"] = \"no logs yet\"\n\n        # Session info\n        if context.session_age_minutes is not None:\n            variables[\"session_age\"] = f\"{context.session_age_minutes:.1f} min\"\n        else:\n            variables[\"session_age\"] = \"\"\n\n        # Phase info\n        if context.current_phase:\n            variables[\"current_phase\"] = context.current_phase\n            variables[\"phase_info\"] = f\"   Phase: {context.current_phase}\"\n            variables[\"phase_suffix\"] = f\" (Phase: {context.current_phase})\"\n        else:\n            variables[\"phase_info\"] = \"\"\n            variables[\"phase_suffix\"] = \"\"\n\n        # Documentation info\n        missing_docs = [name for name, status in context.docs_status.items() if status == \"missing\"]\n        if missing_docs:\n            variables[\"missing_docs\"] = \", \".join(missing_docs[:3])\n            if len(missing_docs) > 3:\n                variables[\"missing_docs\"] += f\" (+{len(missing_docs) - 3} more)\"\n\n        if context.docs_changed:\n            variables[\"changed_docs\"] = \", \".join(context.docs_changed[:3])\n\n        # Merge with context variables\n        variables.update(context.variables)\n\n        return variables\n\n    async def generate_reminders(self, context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Generate relevant reminders for the given context.\"\"\"\n        self._cleanup_history()\n\n        candidates = []\n\n        # Evaluate conditions and generate reminder candidates\n        if \"conditions\" in self.rules:\n            for rule_name, rule_data in self.rules[\"conditions\"].items():\n                if self._evaluate_rule_conditions(rule_data.get(\"triggers\", []), context):\n                    reminder = self._create_reminder_from_rule(rule_name, rule_data, context)\n                    if reminder:\n                        candidates.append(reminder)\n\n        # Add teaching reminders\n        teaching_reminders = self._generate_teaching_reminders(context)\n        candidates.extend(teaching_reminders)\n\n        # Filter and select best reminders\n        selected = self._select_reminders(candidates, context)\n\n        # Track shown reminders\n        for reminder in selected:\n            reminder_hash = self._get_reminder_hash(reminder.key, reminder.variables)\n            self.history.reminder_hashes[reminder_hash] = datetime.now(timezone.utc)\n            self._cooldown_cache_dirty = True\n\n            if reminder.category == \"teaching\":\n                session_key = f\"{context.tool_name}:{reminder.key}\"\n                self.history.teaching_sessions[session_key] = self.history.teaching_sessions.get(session_key, 0) + 1\n\n        self._save_cooldown_cache()\n\n        # Apply formatting\n        use_short = self.config.get(\"formatting\", {}).get(\"use_short_templates\", True)\n        selected = [self._format_reminder(r, use_short) for r in selected]\n\n        return selected\n\n    def _evaluate_rule_conditions(self, triggers: List[str], context: ReminderContext) -> bool:\n        \"\"\"Evaluate if all trigger conditions are met.\"\"\"\n        for trigger in triggers:\n            if not self._evaluate_condition(trigger, context):\n                return False\n        return True\n\n    def _create_reminder_from_rule(self, rule_name: str, rule_data: Dict[str, Any], context: ReminderContext) -> Optional[ReminderInstance]:\n        \"\"\"Create a reminder instance from rule data.\"\"\"\n        reminder_key = rule_data.get(\"reminder_key\")\n        if not reminder_key:\n            return None\n\n        # Navigate reminder structure\n        category, name = reminder_key.split(\".\", 1) if \".\" in reminder_key else (\"general\", reminder_key)\n        reminder_templates = self.reminders.get(\"reminders\", {}).get(category, {}).get(name)\n\n        if not reminder_templates:\n            return None\n\n        variables = self._build_variables(context)\n        variable_mapping = rule_data.get(\"variable_mapping\", {})\n        for key, source in variable_mapping.items():\n            variables[key] = variables.get(source, \"\")\n\n        return ReminderInstance(\n            key=reminder_key,\n            level=reminder_templates.get(\"level\", \"info\"),\n            emoji=reminder_templates.get(\"emoji\", \"\u2139\ufe0f\"),\n            message=reminder_templates.get(\"template\", \"\"),\n            context=reminder_templates.get(\"context\"),\n            category=reminder_templates.get(\"category\", \"general\"),\n            variables=variables,\n            tools_suppressed=reminder_templates.get(\"tools_suppressed\", []),\n            cooldown_minutes=rule_data.get(\"cooldown_minutes\", 0)\n        )\n\n    def _generate_teaching_reminders(self, context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Generate teaching reminders based on context.\"\"\"\n        teaching = []\n\n        if not self.config.get(\"behavior\", {}).get(\"teaching_enabled\", True):\n            return teaching\n\n        teaching_rules = self.rules.get(\"teaching_rules\", {})\n        for rule_name, rule_data in teaching_rules.items():\n            if self._evaluate_rule_conditions(rule_data.get(\"triggers\", []), context):\n                reminder = self._create_reminder_from_rule(rule_name, rule_data, context)\n                if reminder and self._should_show_reminder(reminder, context):\n                    teaching.append(reminder)\n\n        return teaching\n\n    def _select_reminders(self, candidates: List[ReminderInstance], context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Select the best reminders based on priority and rules.\"\"\"\n        if not candidates:\n            return []\n\n        # Filter out suppressed reminders\n        filtered = [r for r in candidates if self._should_show_reminder(r, context)]\n\n        # Sort by priority\n        priority_order = self.config.get(\"selection\", {}).get(\"priority_order\", [])\n        category_weights = self.config.get(\"selection\", {}).get(\"category_weights\", {})\n\n        def get_priority(reminder: ReminderInstance) -> int:\n            # Try priority order first\n            if reminder.key in priority_order:\n                return priority_order.index(reminder.key)\n            # Fall back to category weight\n            return category_weights.get(reminder.level, 999)\n\n        filtered.sort(key=get_priority)\n\n        # Apply tool-specific limits\n        tool_limits = self.config.get(\"selection\", {}).get(\"tool_specific_limits\", {})\n        tool_config = tool_limits.get(context.tool_name, {})\n        max_total = tool_config.get(\"max_total\", self.config.get(\"behavior\", {}).get(\"max_reminders_per_call\", 2))\n        allowed_categories = tool_config.get(\"categories\", [\"all\"])\n\n        if allowed_categories != [\"all\"]:\n            filtered = [r for r in filtered if r.category in allowed_categories]\n\n        return filtered[:max_total]\n\n    def to_dict_list(self, reminders: List[ReminderInstance]) -> List[Dict[str, Any]]:\n        \"\"\"Convert reminder instances to dictionary format for API response.\"\"\"\n        return [\n            {\n                \"level\": r.level,\n                \"score\": r.score,\n                \"emoji\": r.emoji,\n                \"message\": r.message,\n                \"category\": r.category,\n                \"tone\": \"neutral\",  # Can be made configurable\n            }   ({\"context\": r.context} if r.context else {})\n            for r in reminders\n        ]\n", "line_end": 592, "line_start": 401}], "frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "chunk", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/utils/reminder_engine.py", "byte_size": 24475, "encoding": "utf-8", "estimated_chunk_count": 3, "line_count": 592, "newline_type": "LF", "repo_relative_path": "utils/reminder_engine.py", "sha256": "3b52087f6e7bf1fefd74c87814f20198863a1b9632bae80f5855b22c0bf1ec97"}}; timestamp=2026-01-04T01:43:26.533354Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:43:54 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"chunk": {"byte_end": 8325, "byte_start": 1819, "content": "    default_field_selection: List[str]\n    tokenizer_model: str\n    # Reminder system feature flags\n    use_db_cooldown_tracking: bool\n    use_session_aware_hashes: bool\n\n    @classmethod\n    def load(cls) -> \"Settings\":\n        project_root = Path(os.environ.get(\"SCRIBE_ROOT\", _default_root())).resolve()\n        env_state_path = os.environ.get(\"SCRIBE_STATE_PATH\")\n        if env_state_path:\n            state_path = Path(env_state_path).expanduser()\n        else:\n            state_path = (project_root / \".scribe\" / \"state.json\").resolve()\n\n        db_url = os.environ.get(\"SCRIBE_DB_URL\")\n        storage_backend = os.environ.get(\"SCRIBE_STORAGE_BACKEND\")\n        if storage_backend:\n            storage_backend = storage_backend.lower()\n        else:\n            storage_backend = \"postgres\" if db_url else \"sqlite\"\n\n        sqlite_override = os.environ.get(\"SCRIBE_SQLITE_PATH\")\n        if sqlite_override:\n            sqlite_path = Path(sqlite_override).expanduser()\n        else:\n            # Use new data/ directory location\n            sqlite_path = (project_root / \"data\" / \"scribe_projects.db\").resolve()\n\n        allow_network = os.environ.get(\"SCRIBE_ALLOW_NETWORK\", \"false\").lower() in {\n            \"1\",\n            \"true\",\n            \"yes\",\n        }\n        mcp_server_name = os.environ.get(\"SCRIBE_MCP_NAME\", \"scribe.mcp\")\n\n        extra_options = _load_env_json(\"SCRIBE_EXTRA_OPTIONS\")\n        recent_limit_raw = os.environ.get(\"SCRIBE_RECENT_PROJECT_LIMIT\", \"5\")\n        try:\n            recent_limit = max(1, int(recent_limit_raw))\n        except ValueError:\n            recent_limit = 5\n\n        log_rate_limit_count = max(0, _int_env(\"SCRIBE_LOG_RATE_LIMIT_COUNT\", 0))\n        log_rate_limit_window = max(0, _int_env(\"SCRIBE_LOG_RATE_LIMIT_WINDOW\", 60))\n        log_max_bytes = max(0, _int_env(\"SCRIBE_LOG_MAX_BYTES\", 512 * 1024))\n        storage_timeout_seconds = max(0.1, float(os.environ.get(\"SCRIBE_STORAGE_TIMEOUT_SECONDS\", \"5\")))\n        reminder_defaults = _load_env_json(\"SCRIBE_REMINDER_DEFAULTS\")\n        reminder_idle_minutes = max(1, _int_env(\"SCRIBE_REMINDER_IDLE_MINUTES\", 45))\n        reminder_warmup_minutes = max(0, _int_env(\"SCRIBE_REMINDER_WARMUP_MINUTES\", 5))\n\n        dev_plans_base_raw = os.environ.get(\"SCRIBE_DEV_PLANS_BASE\", \".scribe/docs/dev_plans\")\n        dev_plans_base = Path(dev_plans_base_raw).expanduser()\n        if dev_plans_base.is_absolute():\n            # Treat as a relative-to-repo path by stripping the anchor.\n            # This keeps the setting repo-scoped even if an absolute was provided.\n            dev_plans_base = Path(*dev_plans_base.parts[1:])\n\n        # Vector indexing configuration\n        from .vector_config import load_vector_config, merge_with_env_overrides\n\n        vector_config = load_vector_config(project_root)\n        vector_config = merge_with_env_overrides(vector_config)\n\n        vector_enabled = vector_config.enabled\n        vector_backend = vector_config.backend\n        vector_dimension = max(1, vector_config.dimension)\n        vector_model = vector_config.model\n        vector_gpu = vector_config.gpu\n        vector_queue_max = max(1, vector_config.queue_max)\n        vector_batch_size = max(1, vector_config.batch_size)\n\n        # Token optimization configuration\n        default_page_size = max(1, _int_env(\"SCRIBE_DEFAULT_PAGE_SIZE\", 50))\n        max_page_size = max(1, _int_env(\"SCRIBE_MAX_PAGE_SIZE\", 100))\n        default_compact_mode = os.environ.get(\"SCRIBE_DEFAULT_COMPACT_MODE\", \"false\").lower() in {\n            \"1\", \"true\", \"yes\"\n        }\n        token_warning_threshold = max(100, _int_env(\"SCRIBE_TOKEN_WARNING_THRESHOLD\", 4000))\n        token_daily_limit = max(1000, _int_env(\"SCRIBE_TOKEN_DAILY_LIMIT\", 100000))\n        token_operation_limit = max(100, _int_env(\"SCRIBE_TOKEN_OPERATION_LIMIT\", 8000))\n        token_warning_threshold_percent = max(0.1, min(1.0,\n            float(os.environ.get(\"SCRIBE_TOKEN_WARNING_THRESHOLD_PERCENT\", \"0.8\"))\n        ))\n\n        # Default field selection for compact mode\n        default_fields_raw = os.environ.get(\"SCRIBE_DEFAULT_FIELD_SELECTION\",\n            \"id,message,timestamp,emoji,agent\")\n        default_field_selection = [field.strip() for field in default_fields_raw.split(\",\") if field.strip()]\n\n        # Tokenizer model\n        tokenizer_model = os.environ.get(\"SCRIBE_TOKENIZER_MODEL\", \"gpt-4\")\n\n        # Reminder system feature flags (default OFF for backward compatibility)\n        use_db_cooldown_tracking = os.environ.get(\"SCRIBE_REMINDER_USE_DB\", \"false\").lower() in {\n            \"1\", \"true\", \"yes\"\n        }\n        use_session_aware_hashes = os.environ.get(\"SCRIBE_REMINDER_SESSION_HASH\", \"false\").lower() in {\n            \"1\", \"true\", \"yes\"\n        }\n\n        return cls(\n            project_root=project_root,\n            default_state_path=state_path,\n            db_url=db_url,\n            storage_backend=storage_backend,\n            sqlite_path=sqlite_path,\n            allow_network=allow_network,\n            mcp_server_name=mcp_server_name,\n            extra_options=extra_options,\n            recent_projects_limit=recent_limit,\n            log_rate_limit_count=log_rate_limit_count,\n            log_rate_limit_window=log_rate_limit_window,\n            log_max_bytes=log_max_bytes,\n            storage_timeout_seconds=storage_timeout_seconds,\n            reminder_defaults=reminder_defaults,\n            reminder_idle_minutes=reminder_idle_minutes,\n            reminder_warmup_minutes=reminder_warmup_minutes,\n            dev_plans_base=dev_plans_base,\n            vector_enabled=vector_enabled,\n            vector_backend=vector_backend,\n            vector_dimension=vector_dimension,\n            vector_model=vector_model,\n            vector_gpu=vector_gpu,\n            vector_queue_max=vector_queue_max,\n            vector_batch_size=vector_batch_size,\n            default_page_size=default_page_size,\n            max_page_size=max_page_size,\n            default_compact_mode=default_compact_mode,\n            token_warning_threshold=token_warning_threshold,\n            token_daily_limit=token_daily_limit,\n            token_operation_limit=token_operation_limit,\n            token_warning_threshold_percent=token_warning_threshold_percent,\n            default_field_selection=default_field_selection,\n            tokenizer_model=tokenizer_model,\n            use_db_cooldown_tracking=use_db_cooldown_tracking,\n            use_session_aware_hashes=use_session_aware_hashes,\n        )\n\n\ndef _default_root() -> str:\n", "line_end": 210, "line_start": 70}, "frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "line_range", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/config/settings.py", "byte_size": 8670, "encoding": "utf-8", "estimated_chunk_count": 2, "line_count": 225, "newline_type": "LF", "repo_relative_path": "config/settings.py", "sha256": "276a58820003097a0119ff980f8322262a1d62f89d16b79d2155dce1d7b7ec0f"}}; timestamp=2026-01-04T01:43:54.864506Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:44:10 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "scan_only", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/tests/test_reminder_cooldown_cache.py", "byte_size": 1797, "encoding": "utf-8", "estimated_chunk_count": 1, "line_count": 40, "newline_type": "LF", "repo_relative_path": "tests/test_reminder_cooldown_cache.py", "sha256": "057799833af294bdd369182a5e77979858230dbfb010f0f31de677f703b37aa1"}}; timestamp=2026-01-04T01:44:10.310545Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:44:13 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"chunks": [{"byte_end": 1797, "byte_start": 0, "chunk_index": 0, "content": "import os\nfrom datetime import datetime, timezone\nfrom pathlib import Path\n\nfrom scribe_mcp.utils.reminder_engine import ReminderContext, ReminderEngine\n\n\ndef test_reminder_cooldown_cache_roundtrip(monkeypatch, tmp_path):\n    cache_path = tmp_path / \"reminder_cooldowns.json\"\n    monkeypatch.setenv(\"SCRIBE_REMINDER_CACHE_PATH\", str(cache_path))\n\n    engine = ReminderEngine()\n    key = \"/tmp/repo agentA append_entry teaching.example\"\n    engine.history.reminder_hashes[key] = datetime.now(timezone.utc)\n    engine._cooldown_cache_dirty = True  # noqa: SLF001 - test-only access\n    engine._save_cooldown_cache()  # noqa: SLF001 - test-only access\n\n    assert cache_path.exists()\n\n    engine2 = ReminderEngine()\n    assert key in engine2.history.reminder_hashes\n\n\ndef test_reset_cooldowns_scoped_to_project_and_agent(monkeypatch, tmp_path):\n    cache_path = tmp_path / \"reminder_cooldowns.json\"\n    monkeypatch.setenv(\"SCRIBE_REMINDER_CACHE_PATH\", str(cache_path))\n\n    engine = ReminderEngine()\n    engine.history.reminder_hashes[\"/tmp/repo agentA append_entry r1\"] = datetime.now(timezone.utc)\n    engine.history.reminder_hashes[\"/tmp/repo agentB append_entry r2\"] = datetime.now(timezone.utc)\n    engine.history.reminder_hashes[\"/other/repo agentA append_entry r3\"] = datetime.now(timezone.utc)\n    engine._cooldown_cache_dirty = True  # noqa: SLF001 - test-only access\n    engine._save_cooldown_cache()  # noqa: SLF001 - test-only access\n\n    cleared = engine.reset_cooldowns(project_root=\"/tmp/repo\", agent_id=\"agentA\")\n    assert cleared == 1\n    assert \"/tmp/repo agentA append_entry r1\" not in engine.history.reminder_hashes\n    assert \"/tmp/repo agentB append_entry r2\" in engine.history.reminder_hashes\n    assert \"/other/repo agentA append_entry r3\" in engine.history.reminder_hashes\n\n", "line_end": 40, "line_start": 1}], "frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "chunk", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/tests/test_reminder_cooldown_cache.py", "byte_size": 1797, "encoding": "utf-8", "estimated_chunk_count": 1, "line_count": 40, "newline_type": "LF", "repo_relative_path": "tests/test_reminder_cooldown_cache.py", "sha256": "057799833af294bdd369182a5e77979858230dbfb010f0f31de677f703b37aa1"}}; timestamp=2026-01-04T01:44:13.465549Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 01:46:06 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/.scribe/docs/dev_plans/scribe_tool_output_refinement/research/RESEARCH_STAGE7_CLEANUP_TARGETS_20260104_0145.md", "error": "file not found", "mode": "scan_only", "ok": false, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "repo_relative_path": ".scribe/docs/dev_plans/scribe_tool_output_refinement/research/RESEARCH_STAGE7_CLEANUP_TARGETS_20260104_0145.md"}; timestamp=2026-01-04T01:46:06.063635Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 04:43:47 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "scan_only", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/utils/reminder_engine.py", "byte_size": 24475, "encoding": "utf-8", "estimated_chunk_count": 3, "line_count": 592, "newline_type": "LF", "repo_relative_path": "utils/reminder_engine.py", "sha256": "3b52087f6e7bf1fefd74c87814f20198863a1b9632bae80f5855b22c0bf1ec97"}}; timestamp=2026-01-04T04:43:47.969474Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
[ℹ️] [2026-01-04 04:43:54 UTC] [Agent: Scribe] [Project: scribe_tool_output_refinement] Tool call: read_file | format_requested=readable; response_data={"chunks": [{"byte_end": 7426, "byte_start": 0, "chunk_index": 0, "content": "\"\"\"Advanced reminder engine with localization and intelligent selection.\n\nThis module provides a sophisticated reminder system that:\n- Loads reminders from configurable JSON files\n- Supports multiple languages with fallbacks\n- Implements intelligent reminder selection and deduplication\n- Provides progressive teaching with cooldown periods\n- Uses variable substitution for dynamic content\n\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nimport json\nimport os\nimport time\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Set, Tuple\nfrom datetime import datetime, timezone, timedelta\n\nfrom scribe_mcp.config.settings import settings\n\n\n@dataclass\nclass ReminderInstance:\n    \"\"\"A single reminder instance with metadata.\"\"\"\n    key: str\n    level: str\n    emoji: str\n    message: str\n    context: Optional[str] = None\n    category: str = \"general\"\n    score: int = 3\n    variables: Dict[str, Any] = field(default_factory=dict)\n    tools_suppressed: List[str] = field(default_factory=list)\n    cooldown_minutes: int = 0\n    last_shown: Optional[datetime] = None\n\n\n@dataclass\nclass ReminderContext:\n    \"\"\"Context for reminder generation.\"\"\"\n    tool_name: str\n    project_name: Optional[str]\n    project_root: Optional[str]\n    agent_id: Optional[str]\n    session_id: Optional[str] = None\n    total_entries: int = 0\n    minutes_since_log: Optional[float] = None\n    last_log_time: Optional[datetime] = None\n    docs_status: Dict[str, str] = field(default_factory=dict)\n    docs_changed: List[str] = field(default_factory=list)\n    current_phase: Optional[str] = None\n    session_age_minutes: Optional[float] = None\n    variables: Dict[str, Any] = field(default_factory=dict)\n    operation_status: Optional[str] = None  # \"success\", \"failure\", or None for neutral\n\n\n@dataclass\nclass ReminderHistory:\n    \"\"\"Tracks recently shown reminders for deduplication.\"\"\"\n    reminder_hashes: Dict[str, datetime] = field(default_factory=dict)\n    teaching_sessions: Dict[str, int] = field(default_factory=dict)\n    last_cleanup: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n\nclass ReminderEngine:\n    \"\"\"Advanced reminder engine with localization and intelligent selection.\"\"\"\n\n    def __init__(self, config_path: Optional[str] = None):\n        self.config_path = config_path or \"config/reminder_config.json\"\n        self.reminders_path: Optional[str] = None\n        self.rules_path: Optional[str] = None\n\n        self.config: Dict[str, Any] = {}\n        self.reminders: Dict[str, Any] = {}\n        self.rules: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.formatting: Dict[str, Any] = {}\n\n        self.language = \"en-US\"\n        self.fallback_language = \"en-US\"\n\n        self.history = ReminderHistory()\n        self._cooldown_cache_path: Optional[Path] = None\n        self._cooldown_cache_dirty = False\n\n        self._load_configuration()\n\n    def _load_configuration(self) -> None:\n        \"\"\"Load all configuration files.\"\"\"\n        try:\n            config_file = Path(self.config_path)\n            if config_file.exists():\n                self.config = json.loads(config_file.read_text(encoding=\"utf-8\"))\n                self.language = self.config.get(\"language\", \"en-US\")\n                self.fallback_language = self.config.get(\"fallback_language\", \"en-US\")\n\n                base_path = config_file.parent\n                self.reminders_path = base_path / self.config.get(\"reminder_paths\", {}).get(\"templates\", \"reminders\")\n                self.rules_path = base_path / self.config.get(\"reminder_paths\", {}).get(\"rules\", \"reminder_rules.json\")\n\n            self._load_reminders()\n            self._load_rules()\n            self._configure_cooldown_cache()\n            self._load_cooldown_cache()\n\n        except Exception as e:\n            print(f\"Warning: Failed to load reminder configuration: {e}\")\n            self._load_fallback_reminders()\n\n    def _load_reminders(self) -> None:\n        \"\"\"Load reminder templates for current language.\"\"\"\n        if not self.reminders_path:\n            return\n\n        # Try to load preferred language\n        lang_file = self.reminders_path / f\"{self.language}.json\"\n        if lang_file.exists():\n            self.reminders = json.loads(lang_file.read_text(encoding=\"utf-8\"))\n            self.variables = self.reminders.get(\"variables\", {})\n            self.formatting = self.reminders.get(\"formatting\", {})\n            return\n\n        # Fallback to default language\n        fallback_file = self.reminders_path / f\"{self.fallback_language}.json\"\n        if fallback_file.exists():\n            self.reminders = json.loads(fallback_file.read_text(encoding=\"utf-8\"))\n            self.variables = self.reminders.get(\"variables\", {})\n            self.formatting = self.reminders.get(\"formatting\", {})\n\n    def _load_rules(self) -> None:\n        \"\"\"Load reminder selection rules.\"\"\"\n        if not self.rules_path or not self.rules_path.exists():\n            return\n\n        self.rules = json.loads(self.rules_path.read_text(encoding=\"utf-8\"))\n\n    def _load_fallback_reminders(self) -> None:\n        \"\"\"Load minimal fallback reminders.\"\"\"\n        self.reminders = {\n            \"reminders\": {\n                \"logging\": {\n                    \"no_logs_yet\": {\n                        \"level\": \"info\",\n                        \"emoji\": \"\ud83d\udcdd\",\n                        \"template\": \"No progress logs yet. Use append_entry to start the audit trail.\",\n                        \"category\": \"logging\"\n                    }\n                },\n                \"context\": {\n                    \"project_context\": {\n                        \"level\": \"info\",\n                        \"emoji\": \"\ud83c\udfaf\",\n                        \"template\": \"Project: {project_name}\",\n                        \"category\": \"context\"\n                    }\n                }\n            }\n        }\n        self.config = {\n            \"behavior\": {\"max_reminders_per_call\": 2},\n            \"selection\": {\"priority_order\": [\"urgent\", \"warning\", \"info\"]}\n        }\n\n    def _cleanup_history(self) -> None:\n        \"\"\"Clean up old reminder history.\"\"\"\n        now = datetime.now(timezone.utc)\n        cleanup_after_hours = self.config.get(\"tracking\", {}).get(\"cleanup_after_hours\", 24)\n        cutoff = now - timedelta(hours=cleanup_after_hours)\n\n        # Remove old reminder hashes\n        self.history.reminder_hashes = {\n            h: t for h, t in self.history.reminder_hashes.items()\n            if t > cutoff\n        }\n\n        # Remove old teaching sessions\n        self.history.teaching_sessions = {\n            k: v for k, v in self.history.teaching_sessions.items()\n            if v > 0  # Sessions reset when count reaches 0\n        }\n\n        self.history.last_cleanup = now\n\n        # Keep the persisted cooldown cache bounded as well.\n        self._cleanup_cooldown_cache()\n        self._save_cooldown_cache()\n\n    def _configure_cooldown_cache(self) -> None:\n        override = os.environ.get(\"SCRIBE_REMINDER_CACHE_PATH\")\n        if override:\n            self._cooldown_cache_path = Path(override).expanduser()\n            return\n\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        path_raw = behavior.get(\"cooldown_cache_path\", \"data/reminder_cooldowns.json\")\n        path_obj = Path(path_raw).expanduser()\n        if not path_obj.is_absolute():\n", "line_end": 200, "line_start": 1}, {"byte_end": 16238, "byte_start": 7426, "chunk_index": 1, "content": "            path_obj = (settings.project_root / path_obj).resolve()\n        self._cooldown_cache_path = path_obj\n\n    def _load_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        enabled = bool(behavior.get(\"persist_cooldowns\", True))\n        if not enabled or not self._cooldown_cache_path:\n            return\n\n        try:\n            path = self._cooldown_cache_path\n            if not path.exists():\n                return\n            raw = json.loads(path.read_text(encoding=\"utf-8\"))\n            entries = raw.get(\"entries\", raw) if isinstance(raw, dict) else {}\n            if not isinstance(entries, dict):\n                return\n\n            loaded: Dict[str, datetime] = {}\n            for key, ts in entries.items():\n                if not isinstance(key, str) or not isinstance(ts, str):\n                    continue\n                try:\n                    dt = datetime.fromisoformat(ts)\n                    if dt.tzinfo is None:\n                        dt = dt.replace(tzinfo=timezone.utc)\n                    else:\n                        dt = dt.astimezone(timezone.utc)\n                    loaded[key] = dt\n                except ValueError:\n                    continue\n\n            if loaded:\n                self.history.reminder_hashes.update(loaded)\n        except Exception:\n            return\n\n    def _save_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        enabled = bool(behavior.get(\"persist_cooldowns\", True))\n        if not enabled or not self._cooldown_cache_path or not self._cooldown_cache_dirty:\n            return\n\n        try:\n            path = self._cooldown_cache_path\n            path.parent.mkdir(parents=True, exist_ok=True)\n            payload = {\n                \"version\": 1,\n                \"written_at\": datetime.now(timezone.utc).isoformat(),\n                \"entries\": {k: v.isoformat() for k, v in self.history.reminder_hashes.items()},\n            }\n            tmp = path.with_suffix(path.suffix + \".tmp\")\n            tmp.write_text(json.dumps(payload, sort_keys=True), encoding=\"utf-8\")\n            tmp.replace(path)\n            self._cooldown_cache_dirty = False\n        except Exception:\n            return\n\n    def _cleanup_cooldown_cache(self) -> None:\n        behavior = self.config.get(\"behavior\", {}) if isinstance(self.config, dict) else {}\n        retention_minutes = int(behavior.get(\"cooldown_cache_retention_minutes\", 24 * 60))\n        cutoff = datetime.now(timezone.utc) - timedelta(minutes=max(1, retention_minutes))\n        before = len(self.history.reminder_hashes)\n        self.history.reminder_hashes = {\n            k: v for k, v in self.history.reminder_hashes.items()\n            if v >= cutoff\n        }\n        if len(self.history.reminder_hashes) != before:\n            self._cooldown_cache_dirty = True\n\n    def reset_cooldowns(self, *, project_root: str, agent_id: Optional[str] = None) -> int:\n        prefix = f\"{project_root} \"\n        if agent_id:\n            prefix = f\"{project_root} {agent_id} \"\n\n        keys = [k for k in self.history.reminder_hashes.keys() if k.startswith(prefix)]\n        for key in keys:\n            self.history.reminder_hashes.pop(key, None)\n        if keys:\n            self._cooldown_cache_dirty = True\n            self._save_cooldown_cache()\n        return len(keys)\n\n    def _get_reminder_hash(self, reminder_key: str, variables: Dict[str, Any]) -> str:\n        \"\"\"Generate hash for reminder deduplication.\n\n        Uses session_id when use_session_aware_hashes flag is enabled.\n        Falls back to legacy format for backward compatibility.\n        \"\"\"\n        use_session_hash = getattr(settings, 'use_session_aware_hashes', False)\n        session_id = str(variables.get(\"session_id\") or \"\")\n\n        if use_session_hash and session_id:\n            # Session-aware hash (new behavior)\n            parts = [\n                session_id,\n                str(variables.get(\"project_root\") or \"\"),\n                str(variables.get(\"agent_id\") or \"\"),\n                str(variables.get(\"tool_name\") or \"\"),\n                reminder_key\n            ]\n        else:\n            # Legacy hash (backward compatible)\n            parts = [\n                str(variables.get(\"project_root\") or \"\"),\n                str(variables.get(\"agent_id\") or \"\"),\n                str(variables.get(\"tool_name\") or \"\"),\n                reminder_key\n            ]\n\n        return hashlib.md5(\" \".join(parts).encode()).hexdigest()\n\n    def _should_show_reminder(self, reminder: ReminderInstance, context: ReminderContext) -> bool:\n        \"\"\"Check if reminder should be shown based on rules.\n\n        Failure-priority logic: When operation_status == \"failure\", cooldowns are bypassed\n        to ensure critical reminders are shown on tool failures.\n        \"\"\"\n\n        # Tool suppression\n        if context.tool_name in reminder.tools_suppressed:\n            return False\n\n        # Failure-priority logic: bypass cooldowns on failures\n        is_failure = context.operation_status == \"failure\"\n\n        # Cooldown check (bypassed for failures)\n        if not is_failure:\n            cooldown_minutes = reminder.cooldown_minutes\n            if cooldown_minutes <= 0 and reminder.category == \"teaching\":\n                cooldown_minutes = int(self.config.get(\"behavior\", {}).get(\"default_teaching_cooldown_minutes\", 10))\n\n            if cooldown_minutes > 0:\n                reminder_hash = self._get_reminder_hash(reminder.key, reminder.variables)\n                last_shown = self.history.reminder_hashes.get(reminder_hash)\n                if last_shown:\n                    cooldown_cutoff = datetime.now(timezone.utc) - timedelta(minutes=cooldown_minutes)\n                    if last_shown > cooldown_cutoff:\n                        return False\n\n        # Teaching session limits (bypassed for failures)\n        if not is_failure and reminder.category == \"teaching\":\n            session_key = f\"{context.tool_name}:{reminder.key}\"\n            sessions_used = self.history.teaching_sessions.get(session_key, 0)\n            max_sessions = self.config.get(\"behavior\", {}).get(\"max_teaching_reminders_per_session\", 3)\n            if sessions_used >= max_sessions:\n                return False\n\n        return True\n\n    def _format_reminder(self, reminder: ReminderInstance, use_short: bool = True) -> ReminderInstance:\n        \"\"\"Apply variable substitution and formatting to reminder.\"\"\"\n        # Choose template\n        template_key = \"short_template\" if use_short and \"short_template\" in reminder.variables else \"template\"\n        template = reminder.variables.get(template_key, reminder.message)\n\n        # Variable substitution\n        try:\n            formatted_message = template.format(**reminder.variables)\n            if reminder.context:\n                formatted_context = reminder.context.format(**reminder.variables)\n                reminder.context = formatted_context\n        except KeyError as e:\n            # Fallback to original template if variable missing\n            formatted_message = reminder.message\n\n        reminder.message = formatted_message\n        return reminder\n\n    def _evaluate_condition(self, condition: str, context: ReminderContext) -> bool:\n        \"\"\"Evaluate a condition string against context.\"\"\"\n        # Simple condition evaluation (can be extended)\n        if condition == \"no_log_entries\":\n            return context.total_entries == 0\n        elif condition.startswith(\"minutes_since_log > \"):\n            threshold = int(condition.split()[-1])\n            return (context.minutes_since_log or 0) > threshold\n        elif condition == \"docs_missing\":\n            return any(status == \"missing\" for status in context.docs_status.values())\n        elif condition.startswith(\"tool=\"):\n            return context.tool_name == condition.split(\"=\")[1]\n        elif condition.startswith(\"action=\"):\n            return context.variables.get(\"action\") == condition.split(\"=\")[1]\n        elif condition.startswith(\"scaffold=\"):\n            expected = condition.split(\"=\")[1].strip().lower()\n            actual = context.variables.get(\"scaffold\")\n            if isinstance(actual, bool):\n                actual_value = \"true\" if actual else \"false\"\n            else:\n                actual_value = str(actual).strip().lower()\n            return actual_value == expected\n        elif condition == \"always\":\n            return True\n\n        return False\n\n    def _build_variables(self, context: ReminderContext) -> Dict[str, Any]:\n        \"\"\"Build variable dictionary for template substitution.\"\"\"\n        now_utc = datetime.now(timezone.utc)\n        date_format = self.formatting.get(\"date_format\", \"%Y-%m-%d %H:%M UTC\")\n", "line_end": 400, "line_start": 201}, {"byte_end": 24475, "byte_start": 16238, "chunk_index": 2, "content": "\n        variables = {\n            \"project_name\": context.project_name or \"No project\",\n            \"project_root\": context.project_root or \"\",\n            \"agent_id\": context.agent_id or \"\",\n            \"session_id\": context.session_id or \"\",\n            \"tool_name\": context.tool_name,\n            \"total_entries\": context.total_entries,\n            \"minutes\": int(context.minutes_since_log or 0),\n            \"hours\": int((context.minutes_since_log or 0) / 60),\n            \"days\": int((context.minutes_since_log or 0) / 1440),\n            \"now_utc\": now_utc.strftime(date_format),\n            \"now_iso_utc\": now_utc.isoformat(),\n            \"date_utc\": now_utc.strftime(\"%Y-%m-%d\"),\n            \"time_utc\": now_utc.strftime(\"%H:%M:%S UTC\"),\n        }\n\n        # Time formatting\n        if context.last_log_time:\n            variables[\"last_log\"] = context.last_log_time.strftime(\n                date_format\n            )\n        else:\n            variables[\"last_log\"] = \"no logs yet\"\n\n        # Session info\n        if context.session_age_minutes is not None:\n            variables[\"session_age\"] = f\"{context.session_age_minutes:.1f} min\"\n        else:\n            variables[\"session_age\"] = \"\"\n\n        # Phase info\n        if context.current_phase:\n            variables[\"current_phase\"] = context.current_phase\n            variables[\"phase_info\"] = f\"   Phase: {context.current_phase}\"\n            variables[\"phase_suffix\"] = f\" (Phase: {context.current_phase})\"\n        else:\n            variables[\"phase_info\"] = \"\"\n            variables[\"phase_suffix\"] = \"\"\n\n        # Documentation info\n        missing_docs = [name for name, status in context.docs_status.items() if status == \"missing\"]\n        if missing_docs:\n            variables[\"missing_docs\"] = \", \".join(missing_docs[:3])\n            if len(missing_docs) > 3:\n                variables[\"missing_docs\"] += f\" (+{len(missing_docs) - 3} more)\"\n\n        if context.docs_changed:\n            variables[\"changed_docs\"] = \", \".join(context.docs_changed[:3])\n\n        # Merge with context variables\n        variables.update(context.variables)\n\n        return variables\n\n    async def generate_reminders(self, context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Generate relevant reminders for the given context.\"\"\"\n        self._cleanup_history()\n\n        candidates = []\n\n        # Evaluate conditions and generate reminder candidates\n        if \"conditions\" in self.rules:\n            for rule_name, rule_data in self.rules[\"conditions\"].items():\n                if self._evaluate_rule_conditions(rule_data.get(\"triggers\", []), context):\n                    reminder = self._create_reminder_from_rule(rule_name, rule_data, context)\n                    if reminder:\n                        candidates.append(reminder)\n\n        # Add teaching reminders\n        teaching_reminders = self._generate_teaching_reminders(context)\n        candidates.extend(teaching_reminders)\n\n        # Filter and select best reminders\n        selected = self._select_reminders(candidates, context)\n\n        # Track shown reminders\n        for reminder in selected:\n            reminder_hash = self._get_reminder_hash(reminder.key, reminder.variables)\n            self.history.reminder_hashes[reminder_hash] = datetime.now(timezone.utc)\n            self._cooldown_cache_dirty = True\n\n            if reminder.category == \"teaching\":\n                session_key = f\"{context.tool_name}:{reminder.key}\"\n                self.history.teaching_sessions[session_key] = self.history.teaching_sessions.get(session_key, 0) + 1\n\n        self._save_cooldown_cache()\n\n        # Apply formatting\n        use_short = self.config.get(\"formatting\", {}).get(\"use_short_templates\", True)\n        selected = [self._format_reminder(r, use_short) for r in selected]\n\n        return selected\n\n    def _evaluate_rule_conditions(self, triggers: List[str], context: ReminderContext) -> bool:\n        \"\"\"Evaluate if all trigger conditions are met.\"\"\"\n        for trigger in triggers:\n            if not self._evaluate_condition(trigger, context):\n                return False\n        return True\n\n    def _create_reminder_from_rule(self, rule_name: str, rule_data: Dict[str, Any], context: ReminderContext) -> Optional[ReminderInstance]:\n        \"\"\"Create a reminder instance from rule data.\"\"\"\n        reminder_key = rule_data.get(\"reminder_key\")\n        if not reminder_key:\n            return None\n\n        # Navigate reminder structure\n        category, name = reminder_key.split(\".\", 1) if \".\" in reminder_key else (\"general\", reminder_key)\n        reminder_templates = self.reminders.get(\"reminders\", {}).get(category, {}).get(name)\n\n        if not reminder_templates:\n            return None\n\n        variables = self._build_variables(context)\n        variable_mapping = rule_data.get(\"variable_mapping\", {})\n        for key, source in variable_mapping.items():\n            variables[key] = variables.get(source, \"\")\n\n        return ReminderInstance(\n            key=reminder_key,\n            level=reminder_templates.get(\"level\", \"info\"),\n            emoji=reminder_templates.get(\"emoji\", \"\u2139\ufe0f\"),\n            message=reminder_templates.get(\"template\", \"\"),\n            context=reminder_templates.get(\"context\"),\n            category=reminder_templates.get(\"category\", \"general\"),\n            variables=variables,\n            tools_suppressed=reminder_templates.get(\"tools_suppressed\", []),\n            cooldown_minutes=rule_data.get(\"cooldown_minutes\", 0)\n        )\n\n    def _generate_teaching_reminders(self, context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Generate teaching reminders based on context.\"\"\"\n        teaching = []\n\n        if not self.config.get(\"behavior\", {}).get(\"teaching_enabled\", True):\n            return teaching\n\n        teaching_rules = self.rules.get(\"teaching_rules\", {})\n        for rule_name, rule_data in teaching_rules.items():\n            if self._evaluate_rule_conditions(rule_data.get(\"triggers\", []), context):\n                reminder = self._create_reminder_from_rule(rule_name, rule_data, context)\n                if reminder and self._should_show_reminder(reminder, context):\n                    teaching.append(reminder)\n\n        return teaching\n\n    def _select_reminders(self, candidates: List[ReminderInstance], context: ReminderContext) -> List[ReminderInstance]:\n        \"\"\"Select the best reminders based on priority and rules.\"\"\"\n        if not candidates:\n            return []\n\n        # Filter out suppressed reminders\n        filtered = [r for r in candidates if self._should_show_reminder(r, context)]\n\n        # Sort by priority\n        priority_order = self.config.get(\"selection\", {}).get(\"priority_order\", [])\n        category_weights = self.config.get(\"selection\", {}).get(\"category_weights\", {})\n\n        def get_priority(reminder: ReminderInstance) -> int:\n            # Try priority order first\n            if reminder.key in priority_order:\n                return priority_order.index(reminder.key)\n            # Fall back to category weight\n            return category_weights.get(reminder.level, 999)\n\n        filtered.sort(key=get_priority)\n\n        # Apply tool-specific limits\n        tool_limits = self.config.get(\"selection\", {}).get(\"tool_specific_limits\", {})\n        tool_config = tool_limits.get(context.tool_name, {})\n        max_total = tool_config.get(\"max_total\", self.config.get(\"behavior\", {}).get(\"max_reminders_per_call\", 2))\n        allowed_categories = tool_config.get(\"categories\", [\"all\"])\n\n        if allowed_categories != [\"all\"]:\n            filtered = [r for r in filtered if r.category in allowed_categories]\n\n        return filtered[:max_total]\n\n    def to_dict_list(self, reminders: List[ReminderInstance]) -> List[Dict[str, Any]]:\n        \"\"\"Convert reminder instances to dictionary format for API response.\"\"\"\n        return [\n            {\n                \"level\": r.level,\n                \"score\": r.score,\n                \"emoji\": r.emoji,\n                \"message\": r.message,\n                \"category\": r.category,\n                \"tone\": \"neutral\",  # Can be made configurable\n            }   ({\"context\": r.context} if r.context else {})\n            for r in reminders\n        ]\n", "line_end": 592, "line_start": 401}], "frontmatter": {}, "frontmatter_byte_count": 0, "frontmatter_line_count": 0, "frontmatter_raw": "", "has_frontmatter": false, "mode": "chunk", "ok": true, "reminders": [{"category": "context", "context": "Entries:    Last: ", "emoji": "\ud83c\udfaf", "level": "info", "message": "Project: scribe_tool_output_refinement", "score": 3, "tone": "neutral"}], "scan": {"absolute_path": "/home/austin/projects/MCP_SPINE/scribe_mcp/utils/reminder_engine.py", "byte_size": 24475, "encoding": "utf-8", "estimated_chunk_count": 3, "line_count": 592, "newline_type": "LF", "repo_relative_path": "utils/reminder_engine.py", "sha256": "3b52087f6e7bf1fefd74c87814f20198863a1b9632bae80f5855b22c0bf1ec97"}}; timestamp=2026-01-04T04:43:54.011105Z; tool=read_file; priority=medium; log_type=tool_logs; content_type=log
